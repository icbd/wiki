---
layout: post
title:  Redis bit 的反直觉特性
date:   2019-03-29
categories: Redis
---

Redis 里 `String` 的数据结构都不陌生了, 这里介绍一点使用 `String` 的 `BitMap` 特性时, 遇到的反直觉的特性.

### 前情回顾

学C语言讲ASCII编码的时候, 我们就知道了字符的编码:
 
 ```ruby
'h'.ord
# 104
'h'.ord.to_s(2)
# "1101000"
'i'.ord
# 105
'i'.ord.to_s(2)
# "1101001"

# (<=Byte High)    0110 1000    0110 1001    (Byte Low=>)
# => Memory growth direction =>  
```

关于大端模式和小端模式.

上面例子, `h` 对应的二进制的存储为 `0110 1000`, 正想我们看到的这样, 右边为字节的低位, 左边为高位, index 从左向右数 依次增大.

也是为了顾及人类的可读性, 网络传输中使用了 `大端模式` .

但是如此一来, 就不方便机器处理了, 因为 `大端模式` 跟 内存的增长顺序相反. 

`小端模式` 就是字节的高位对应内存地址的高位, 机器处理的时候就省去了翻转的操作, 提升效率.

### Redis 的 String 使用小端模式

UTF8下, 每个英文字符占一个byte, 一个byte八个bit. `unshift` 方法把每个取出的值从左边插入, 类似 `lpush` .

```ruby
require 'redis'

conn = Redis.new

conn.set('key', 'hi')
p value = conn.get('key')
# "hi"

bits = []
(value.bytesize * 8).times do |index|
  bits.unshift conn.getbit('key', index)
end
p bits.join
# "1001011000010110"
```

Redis中, 以 `BitMap` 存贮的数据跟普通的字符串并没有什么不同, 只是我们赋予了这些二进制不同的含义.

我们可以按照 `01101000 01101001` 的顺序依次设置bit位, 然后用字符串的形式来读取 (只是试验, 没人会这样干):

```ruby
conn.del('key')
bits = '0110100001101001'.split('').map(&:to_i)
p bits # [0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1]
bits.each_with_index do |value, index|
  conn.setbit('key', index, value)
end
p conn.get('key')
# "hi"
```

### Redis 的 bitcount 按字节计算

`start` 和 `end` 是闭区间, 单位是 **byte** . 

```text
BITCOUNT key [start end]
```

官方文档虽然有写是根据bytes, 但是直觉反应是按照bit计算啊, 如果没注意就很惨 ~

```ruby
conn.del('key')

conn.setbit('key', 6, 1)
conn.setbit('key', 7, 1)
conn.setbit('key', 8, 1)
conn.setbit('key', 16, 1)

p conn.bitcount('key')
# 4
p conn.bitcount('key', 0, 1)
# 3
```

第一个byte是 `0~7`,
第一个byte是 `8~15`,
第一个byte是 `16~23`.

假设 `BitMap` 中保存的是用户按天打卡的数据, 如果想要某个月份的打卡总数, 只能自己算了 (可以先 `getrange` 再算) .

### Reference

[https://redis.io/commands/bitcount](https://redis.io/commands/bitcount)

[http://doc.redisfans.com/](http://doc.redisfans.com/) 